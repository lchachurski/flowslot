#!/bin/bash
# Open (create or resume) a slot
# Usage: slot open <name> [branch]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

# Source common functions
# shellcheck source=lib/common.sh
source "$LIB_DIR/common.sh"

show_help() {
  cat << EOF
Usage: slot open <name> [branch]

Opens or creates a development slot.

Arguments:
  name      Slot name (lowercase alphanumeric with hyphens only)
  branch    Git branch name (default: main)

Options:
  -h, --help    Show this help message

Examples:
  slot open auth main
  slot open feature-branch feat/new-ui
EOF
}

# Handle help flag
if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  show_help
  exit 0
fi

if [ -z "${1:-}" ]; then
  log_error "Slot name required"
  echo ""
  show_help
  exit 1
fi

SLOT_NAME="$1"
BRANCH="${2:-main}"

# Validate slot name
validate_slot_name "$SLOT_NAME"

LOCAL_PATH="$SLOT_SLOTS_DIR/$SLOT_NAME"
REMOTE_PATH="$SLOT_REMOTE_BASE/$SLOT_NAME"

# Check if slot already exists locally
if [ -d "$LOCAL_PATH" ]; then
  log_info "Slot '$SLOT_NAME' already exists locally. Resuming..."
else
  log_info "Creating slot '$SLOT_NAME' on branch '$BRANCH'..."
  
  # Setup local worktree from the bare repo
  log_info "Setting up local worktree..."
  cd "$SLOT_SLOTS_DIR/repo.git"
  
  # Fetch if origin exists
  if git remote get-url origin >/dev/null 2>&1; then
    git fetch --all --prune 2>/dev/null || true
  fi
  
  # Create worktree
  git worktree add "$LOCAL_PATH" "$BRANCH" 2>/dev/null || \
  git worktree add "$LOCAL_PATH" -b "$BRANCH" origin/"$BRANCH" 2>/dev/null || \
  git worktree add "$LOCAL_PATH" HEAD
fi

# Create remote directory (Mutagen will sync files there)
log_info "Setting up remote directory..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SETUP
  set -e
  # Ensure base directory exists with correct permissions
  if [ ! -d '$SLOT_REMOTE_BASE' ]; then
    sudo mkdir -p '$SLOT_REMOTE_BASE'
    sudo chown \$USER:\$USER '$SLOT_REMOTE_BASE'
  fi
  # Create slot directory
  mkdir -p '$REMOTE_PATH'
REMOTE_SETUP

# Copy environment files from templates to local worktree
log_info "Copying environment files..."
if [ -d "$SLOT_TEMPLATE_DIR" ]; then
  find "$SLOT_TEMPLATE_DIR" -name ".env*" -type f | while read -r template_file; do
    rel_path="${template_file#$SLOT_TEMPLATE_DIR/}"
    local_env="$LOCAL_PATH/$rel_path"
    
    # Copy to local (Mutagen will sync to remote)
    mkdir -p "$(dirname "$local_env")"
    cp "$template_file" "$local_env"
    log_info "  Copied: $rel_path"
  done
fi

# Start Mutagen sync (local â†’ remote)
SYNC_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
log_info "Starting Mutagen sync..."

# Check if sync already exists
if mutagen sync list --label-selector="name=$SYNC_NAME" 2>/dev/null | grep -q "Name:"; then
  log_info "  Terminating stale sync..."
  mutagen sync terminate "$SYNC_NAME" 2>/dev/null || true
fi

# Clear remote directory for fresh sync
log_info "  Preparing remote directory..."
ssh "$SLOT_REMOTE_HOST" "rm -rf '$REMOTE_PATH' && mkdir -p '$REMOTE_PATH'"

# Create fresh sync
log_info "  Creating sync..."
mutagen sync create \
  "$LOCAL_PATH" \
  "$SLOT_REMOTE_HOST:$REMOTE_PATH" \
  --name="$SYNC_NAME" \
  --label="name=$SYNC_NAME" \
  --ignore=".git" \
  --ignore="node_modules" \
  --ignore=".next" \
  --ignore="dist" \
  --ignore="*.log" \
  --ignore=".DS_Store" \
  --sync-mode=two-way-resolved \
  --default-file-mode=0644 \
  --default-directory-mode=0755

# Wait for sync to complete initial transfer
log_info "Waiting for sync to complete..."
for i in {1..30}; do
  if mutagen sync flush "$SYNC_NAME" 2>/dev/null; then
    break
  fi
  sleep 1
done

# Calculate port base using persistent slot number
# Each slot stores its number in .slot_num file
SLOT_NUM=$(ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SLOT_NUM
  set -euo pipefail
  SLOT_NUM_FILE='$REMOTE_PATH/.slot_num'
  
  if [ -f "\$SLOT_NUM_FILE" ]; then
    # Use existing slot number
    cat "\$SLOT_NUM_FILE"
  else
    # Find next available slot number (1-based)
    USED_NUMS=\$(find '$SLOT_REMOTE_BASE' -name '.slot_num' -exec cat {} \\; 2>/dev/null | sort -n)
    NEXT_NUM=1
    for n in \$USED_NUMS; do
      if [ "\$n" -eq "\$NEXT_NUM" ]; then
        NEXT_NUM=\$((NEXT_NUM + 1))
      fi
    done
    echo "\$NEXT_NUM" > "\$SLOT_NUM_FILE"
    echo "\$NEXT_NUM"
  fi
REMOTE_SLOT_NUM
)
PORT_BASE=$((PORT_BASE_START + SLOT_NUM * PORT_RANGE))

# Get Tailscale IP for accessing services
TAILSCALE_IP=$(ssh "$SLOT_REMOTE_HOST" "tailscale ip -4 2>/dev/null" | head -1 || echo "")

# Start containers with dynamic ports
log_info "Starting containers..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SCRIPT
  set -e
  cd '$REMOTE_PATH'
  
  # Export slot variables
  export SLOT=$SLOT_NUM
  export SLOT_PORT_BASE=$PORT_BASE
  export SLOT_REMOTE_IP="${TAILSCALE_IP:-localhost}"
  export COMPOSE_PROJECT_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
  
  # Source project-specific port definitions if they exist
  if [ -f 'flowslot-ports.sh' ]; then
    source flowslot-ports.sh
  fi
  
  # Build compose command from configured files
  COMPOSE_FILES="${SLOT_COMPOSE_FILES}"
  COMPOSE_CMD="docker compose"
  for f in \$COMPOSE_FILES; do
    if [ -f "\$f" ]; then
      COMPOSE_CMD="\$COMPOSE_CMD -f \$f"
    fi
  done
  
  # Add flowslot override file if it exists and not already included
  if [ -f 'docker-compose.flowslot.yml' ]; then
    if ! echo "\$COMPOSE_CMD" | grep -q 'docker-compose.flowslot.yml'; then
      COMPOSE_CMD="\$COMPOSE_CMD -f docker-compose.flowslot.yml"
    fi
  fi
  
  echo "Running: \$COMPOSE_CMD up -d"
  eval "\$COMPOSE_CMD up -d"
REMOTE_SCRIPT

echo ""
success "Slot '$SLOT_NAME' is ready!"
echo ""
echo "  Local:  $LOCAL_PATH"
echo "  Remote: $SLOT_REMOTE_HOST:$REMOTE_PATH"
echo "  Branch: $BRANCH"
echo "  Ports:  $PORT_BASE - $((PORT_BASE + PORT_RANGE - 1))"
if [ -n "${TAILSCALE_IP:-}" ]; then
  echo "  Access: http://$TAILSCALE_IP:$((PORT_BASE + 1))"
fi
echo ""
echo "Open in Cursor: cursor $LOCAL_PATH"
