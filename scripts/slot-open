#!/bin/bash
# Open (create or resume) a slot
# Usage: slot open <name> [branch]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

# Source common functions
# shellcheck source=lib/common.sh
source "$LIB_DIR/common.sh"

show_help() {
  cat << EOF
Usage: slot open <name> [branch]

Opens or creates a development slot.

Arguments:
  name      Slot name (lowercase alphanumeric with hyphens only)
  branch    Git branch name (default: main)

Options:
  -h, --help    Show this help message

Examples:
  slot open auth main
  slot open feature-branch feat/new-ui
EOF
}

# Handle help flag
if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  show_help
  exit 0
fi

if [ -z "${1:-}" ]; then
  log_error "Slot name required"
  echo ""
  show_help
  exit 1
fi

SLOT_NAME="$1"
BRANCH="${2:-main}"

# Validate slot name
validate_slot_name "$SLOT_NAME"

LOCAL_PATH="$SLOT_SLOTS_DIR/$SLOT_NAME"
REMOTE_PATH="$SLOT_REMOTE_BASE/$SLOT_NAME"

# Check if slot already exists locally
if [ -d "$LOCAL_PATH" ]; then
  log_info "Slot '$SLOT_NAME' already exists locally. Resuming..."
else
  log_info "Creating slot '$SLOT_NAME' on branch '$BRANCH'..."
fi

# Setup remote worktree
log_info "Setting up remote worktree..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SCRIPT
  set -e
  cd '$SLOT_REMOTE_BASE/repo.git'
  git fetch --all --prune
  
  # Check if branch exists
  if ! git rev-parse --verify "origin/$BRANCH" >/dev/null 2>&1; then
    echo "Error: Branch '$BRANCH' not found in remote"
    exit 1
  fi
  
  # Create or checkout worktree
  if [ -d '$REMOTE_PATH' ]; then
    cd '$REMOTE_PATH'
    git checkout '$BRANCH' || git checkout -b '$BRANCH' origin/'$BRANCH'
    git pull origin '$BRANCH' || true
  else
    git worktree add '$REMOTE_PATH' '$BRANCH' || git worktree add '$REMOTE_PATH' -b '$BRANCH' origin/'$BRANCH'
  fi
REMOTE_SCRIPT

# Setup local worktree
log_info "Setting up local worktree..."
cd "$SLOT_SLOTS_DIR/repo.git"
git fetch --all --prune

if [ -d "$LOCAL_PATH" ]; then
  cd "$LOCAL_PATH"
  git checkout "$BRANCH" || git checkout -b "$BRANCH" origin/"$BRANCH"
  git pull origin "$BRANCH" || true
else
  git worktree add "$LOCAL_PATH" "$BRANCH" || git worktree add "$LOCAL_PATH" -b "$BRANCH" origin/"$BRANCH"
fi

# Copy environment files from templates
log_info "Copying environment files..."
if [ -d "$SLOT_TEMPLATE_DIR" ]; then
  find "$SLOT_TEMPLATE_DIR" -name ".env*" -type f | while read -r template_file; do
    rel_path="${template_file#$SLOT_TEMPLATE_DIR/}"
    local_env="$LOCAL_PATH/$rel_path"
    remote_env="$REMOTE_PATH/$rel_path"
    
    # Copy to local
    mkdir -p "$(dirname "$local_env")"
    cp "$template_file" "$local_env"
    
    # Copy to remote
    ssh "$SLOT_REMOTE_HOST" "mkdir -p \"\$(dirname '$remote_env')\""
    scp "$template_file" "$SLOT_REMOTE_HOST:$remote_env"
  done
fi

# Start Mutagen sync
SYNC_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
log_info "Starting Mutagen sync..."
if mutagen sync list 2>/dev/null | grep -q "^$SYNC_NAME"; then
  mutagen sync resume "$SYNC_NAME" 2>/dev/null || true
else
  mutagen sync create \
    "$LOCAL_PATH" \
    "$SLOT_REMOTE_HOST:$REMOTE_PATH" \
    --name="$SYNC_NAME" \
    --ignore=".git" \
    --ignore="node_modules" \
    --ignore=".next" \
    --ignore="dist" \
    --ignore="build" \
    --ignore="*.log" \
    --ignore=".DS_Store" \
    --sync-mode=two-way-resolved \
    --default-file-mode=0644 \
    --default-directory-mode=0755
fi

# Wait for sync to be ready
log_info "Waiting for sync to initialize..."
sleep 2
mutagen sync flush "$SYNC_NAME" || true

# Find next available slot number
SLOT_NUM=1
while ssh "$SLOT_REMOTE_HOST" "[ -d '$SLOT_REMOTE_BASE/slot-$SLOT_NUM' ]" 2>/dev/null; do
  SLOT_NUM=$((SLOT_NUM + 1))
done

# Calculate port base using constants
PORT_BASE=$((PORT_BASE_START + SLOT_NUM * PORT_RANGE))

# Get Tailscale IP for webhook URLs
TAILSCALE_IP=$(ssh "$SLOT_REMOTE_HOST" "tailscale ip -4" | head -1 || echo "")

# Start containers with dynamic ports
log_info "Starting containers..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SCRIPT
  set -e
  cd '$REMOTE_PATH'
  
  # Export generic slot variables
  export SLOT=$SLOT_NUM
  export SLOT_PORT_BASE=$PORT_BASE
  export SLOT_REMOTE_IP="${TAILSCALE_IP:-localhost}"
  export COMPOSE_PROJECT_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
  SLOT_COMPOSE_FILES="${SLOT_COMPOSE_FILES}"
  
  # Source project-specific port definitions if they exist
  if [ -f 'slot-ports.sh' ]; then
    source slot-ports.sh
  fi
  
  # Build compose command from configured files
  COMPOSE_CMD="docker compose"
  for f in \$SLOT_COMPOSE_FILES; do
    COMPOSE_CMD="\$COMPOSE_CMD -f \$f"
  done
  
  # Add slot override file if it exists
  if [ -f 'docker-compose.slot.yml' ]; then
    COMPOSE_CMD="\$COMPOSE_CMD -f docker-compose.slot.yml"
  fi
  
  eval "\$COMPOSE_CMD up -d"
REMOTE_SCRIPT

echo ""
success "Slot '$SLOT_NAME' is ready!"
echo "  Branch: $BRANCH"
echo "  Port base: $PORT_BASE"
echo "  Remote: $SLOT_REMOTE_HOST:$REMOTE_PATH"
if [ -n "${TAILSCALE_IP:-}" ]; then
  echo "  Tailscale IP: $TAILSCALE_IP"
fi

