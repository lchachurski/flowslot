#!/bin/bash
# Create a slot
# Usage: slot create <name> [branch]

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

# Source common functions
# shellcheck source=lib/common.sh
source "$LIB_DIR/common.sh"

show_help() {
  cat << EOF
Usage: slot create <name> [branch]

Creates a new development slot.

Arguments:
  name      Slot name (lowercase alphanumeric with hyphens only)
  branch    Git branch name (default: main)

Options:
  -h, --help    Show this help message

Examples:
  slot create auth main
  slot create feature-branch feat/new-ui
EOF
}

# Handle help flag
if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  show_help
  exit 0
fi

if [ -z "${1:-}" ]; then
  log_error "Slot name required"
  echo ""
  show_help
  exit 1
fi

SLOT_NAME="$1"
BRANCH="${2:-main}"

# Validate slot name
validate_slot_name "$SLOT_NAME"

LOCAL_PATH="$SLOT_SLOTS_DIR/$SLOT_NAME"
REMOTE_PATH="$SLOT_REMOTE_BASE/$SLOT_NAME"

# Check if slot already exists locally
if [ -d "$LOCAL_PATH" ]; then
  die "Slot '$SLOT_NAME' already exists. Use 'slot resume $SLOT_NAME' to resume it, or 'slot destroy $SLOT_NAME' to delete it."
fi

log_info "Creating slot '$SLOT_NAME' on branch '$BRANCH'..."
  
  # Setup local worktree from the bare repo
  log_info "Setting up local worktree..."
  cd "$SLOT_SLOTS_DIR/repo.git"
  
  # Fetch if origin exists
  if git remote get-url origin >/dev/null 2>&1; then
    git fetch --all --prune 2>/dev/null || true
  fi
  
  # Create worktree
  git worktree add "$LOCAL_PATH" "$BRANCH" 2>/dev/null || \
  git worktree add "$LOCAL_PATH" -b "$BRANCH" origin/"$BRANCH" 2>/dev/null || \
  git worktree add "$LOCAL_PATH" HEAD

# Symlink .slotconfig into slot directory so commands work from there
CONFIG_SOURCE="$SLOT_SOURCE_DIR/.slotconfig"
CONFIG_LINK="$LOCAL_PATH/.slotconfig"
if [ -f "$CONFIG_SOURCE" ] && [ ! -e "$CONFIG_LINK" ]; then
  ln -s "$CONFIG_SOURCE" "$CONFIG_LINK"
  log_info "Linked .slotconfig for slot directory access"
fi

# Create remote directory (Mutagen will sync files there)
log_info "Setting up remote directory..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SETUP
  set -e
  # Ensure base directory exists with correct permissions
  if [ ! -d '$SLOT_REMOTE_BASE' ]; then
    sudo mkdir -p '$SLOT_REMOTE_BASE'
    sudo chown \$USER:\$USER '$SLOT_REMOTE_BASE'
  fi
  # Create slot directory
  mkdir -p '$REMOTE_PATH'
REMOTE_SETUP

# Copy environment files from templates to local worktree
log_info "Copying environment files..."
if [ -d "$SLOT_TEMPLATE_DIR" ]; then
  find "$SLOT_TEMPLATE_DIR" -name ".env*" -type f | while read -r template_file; do
    rel_path="${template_file#$SLOT_TEMPLATE_DIR/}"
    local_env="$LOCAL_PATH/$rel_path"
    
    # Copy to local (Mutagen will sync to remote)
    mkdir -p "$(dirname "$local_env")"
    cp "$template_file" "$local_env"
    log_info "  Copied: $rel_path"
  done
fi

# Start Mutagen sync (local â†’ remote)
SYNC_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
log_info "Starting Mutagen sync..."

# Check if sync already exists
if mutagen sync list --label-selector="name=$SYNC_NAME" 2>/dev/null | grep -q "Name:"; then
  log_info "  Terminating stale sync..."
  mutagen sync terminate "$SYNC_NAME" 2>/dev/null || true
fi

# Clear remote directory for fresh sync
log_info "  Preparing remote directory..."
ssh "$SLOT_REMOTE_HOST" "rm -rf '$REMOTE_PATH' && mkdir -p '$REMOTE_PATH'"

# Create fresh sync
log_info "  Creating sync..."
mutagen sync create \
  "$LOCAL_PATH" \
  "$SLOT_REMOTE_HOST:$REMOTE_PATH" \
  --name="$SYNC_NAME" \
  --label="name=$SYNC_NAME" \
  --ignore=".git" \
  --ignore="node_modules" \
  --ignore=".next" \
  --ignore="dist" \
  --ignore="*.log" \
  --ignore=".DS_Store" \
  --sync-mode=two-way-resolved \
  --default-file-mode=0644 \
  --default-directory-mode=0755

# Wait for sync to complete initial transfer
log_info "Waiting for sync to complete..."
for i in {1..30}; do
  if mutagen sync flush "$SYNC_NAME" 2>/dev/null; then
    break
  fi
  sleep 1
done

# Calculate slot number dynamically by counting existing slots
# Slot number = count of existing slot directories that have docker-compose files (0-based)
SLOT_NUM=$(ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SLOT_NUM
  set -euo pipefail
  # Count existing slot directories (those with docker-compose.yml or docker-compose.dev.yml)
  # Exclude the current slot being created
  COUNT=0
  for dir in '$SLOT_REMOTE_BASE'/*/; do
    dirname=\$(basename "\$dir")
    if [ "\$dirname" != "$SLOT_NAME" ] && [ -f "\$dir/docker-compose.yml" -o -f "\$dir/docker-compose.dev.yml" ]; then
      COUNT=\$((COUNT + 1))
    fi
  done
  echo "\$COUNT"
REMOTE_SLOT_NUM
)
PORT_BASE=$((PORT_BASE_START + SLOT_NUM * PORT_RANGE))

# Get Tailscale IP for accessing services
TAILSCALE_IP=$(ssh "$SLOT_REMOTE_HOST" "tailscale ip -4 2>/dev/null" | head -1 || echo "")

# Start containers with dynamic ports
log_info "Starting containers..."
ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SCRIPT
  set -e
  cd '$REMOTE_PATH'
  
  # Export slot variables
  export SLOT=$SLOT_NUM
  export SLOT_NAME="${SLOT_NAME}"
  export SLOT_PORT_BASE=$PORT_BASE
  export SLOT_PROJECT_NAME="${SLOT_PROJECT_NAME}"
  export SLOT_REMOTE_IP="${TAILSCALE_IP:-localhost}"
  export COMPOSE_PROJECT_NAME="${SLOT_PROJECT_NAME}-${SLOT_NAME}"
  
  # Source project-specific port definitions if they exist
  if [ -f 'flowslot-ports.sh' ]; then
    source flowslot-ports.sh
  fi
  
  # Build compose command from configured files
  COMPOSE_FILES="${SLOT_COMPOSE_FILES}"
  COMPOSE_CMD="docker compose"
  for f in \$COMPOSE_FILES; do
    if [ -f "\$f" ]; then
      COMPOSE_CMD="\$COMPOSE_CMD -f \$f"
    fi
  done
  
  # Add flowslot override file if it exists and not already included
  if [ -f 'docker-compose.flowslot.yml' ]; then
    if ! echo "\$COMPOSE_CMD" | grep -q 'docker-compose.flowslot.yml'; then
      COMPOSE_CMD="\$COMPOSE_CMD -f docker-compose.flowslot.yml"
    fi
  fi
  
  echo "Running: \$COMPOSE_CMD up -d"
  eval "\$COMPOSE_CMD up -d"
REMOTE_SCRIPT

echo ""
success "Slot '$SLOT_NAME' is ready!"
echo ""
echo "  Local:  $LOCAL_PATH"
echo "  Remote: $SLOT_REMOTE_HOST:$REMOTE_PATH"
echo "  Branch: $BRANCH"
echo "  Ports:  $PORT_BASE - $((PORT_BASE + PORT_RANGE - 1))"
if [ -n "${TAILSCALE_IP:-}" ]; then
  echo "  Access: http://$TAILSCALE_IP:$((PORT_BASE + 1))"
fi
echo ""
echo "Open in Cursor: cursor $LOCAL_PATH"
