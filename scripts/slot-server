#!/bin/bash
# Manage EC2 instance
# Usage: slot server <start|stop|status>

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="$SCRIPT_DIR/lib"

# Source common functions
# shellcheck source=lib/common.sh
source "$LIB_DIR/common.sh"

show_help() {
  cat << EOF
Usage: slot server <start|stop|status|info|recreate>

Manage the EC2 instance for flowslot.

Commands:
  start     Start the EC2 instance
  stop      Stop the EC2 instance
  status    Show instance status
  info      Show server resource usage (CPU, RAM, disk)
  recreate  Terminate current instance and create a new one
            (Use when Spot capacity is unavailable)

Options:
  -h, --help    Show this help message
EOF
}

# Handle help flag
if [ "${1:-}" = "-h" ] || [ "${1:-}" = "--help" ]; then
  show_help
  exit 0
fi

if [ -z "${1:-}" ]; then
  log_error "Command required"
  echo ""
  show_help
  exit 1
fi

COMMAND="$1"

# Check if instance ID is configured
if [ -z "${SLOT_AWS_INSTANCE_ID:-}" ] || [ -z "${SLOT_AWS_REGION:-}" ]; then
  die "SLOT_AWS_INSTANCE_ID and SLOT_AWS_REGION must be set in .slotconfig. Run 'slot self init' to configure."
fi

case "$COMMAND" in
  start)
    log_info "Starting instance $SLOT_AWS_INSTANCE_ID..."
    
    # Capture start-instances output and errors
    START_OUTPUT=$(aws ec2 start-instances \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" \
      --output text 2>&1) || true
    
    # Check for Spot capacity error
    if echo "$START_OUTPUT" | grep -q "InsufficientInstanceCapacity"; then
      # Get instance AZ for helpful info
      AZ=$(aws ec2 describe-instances \
        --instance-ids "$SLOT_AWS_INSTANCE_ID" \
        --region "$SLOT_AWS_REGION" \
        --query 'Reservations[0].Instances[0].Placement.AvailabilityZone' \
        --output text 2>/dev/null || echo "unknown")
      
      INSTANCE_TYPE=$(aws ec2 describe-instances \
        --instance-ids "$SLOT_AWS_INSTANCE_ID" \
        --region "$SLOT_AWS_REGION" \
        --query 'Reservations[0].Instances[0].InstanceType' \
        --output text 2>/dev/null || echo "unknown")
      
      log_error "No Spot capacity available for $INSTANCE_TYPE in $AZ"
      echo ""
      echo "This is a temporary AWS Spot capacity issue — capacity fluctuates."
      echo ""
      echo "Options:"
      echo "  1. Retry later — try again in a few minutes"
      echo "  2. Recreate instance with fallback types:"
      echo "     cd ~/.flowslot/infra && ./create-instance.sh"
      echo ""
      echo "     WARNING: This creates a NEW instance."
      echo "     Update .slotconfig with the new Instance ID afterward."
      echo ""
      echo "Current instance: $SLOT_AWS_INSTANCE_ID"
      echo "Instance type:    $INSTANCE_TYPE"
      echo "Availability Zone: $AZ"
      exit 1
    fi
    
    # Check for other errors
    if echo "$START_OUTPUT" | grep -qi "error"; then
      log_error "Failed to start instance"
      echo "$START_OUTPUT"
      exit 1
    fi
    
    log_info "Waiting for instance to be running..."
    aws ec2 wait instance-running \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION"
    
    # Get Tailscale IP (with retry)
    log_info "Waiting for Tailscale to connect..."
    for i in {1..6}; do
      sleep 5
      TAILSCALE_IP=$(ssh "$SLOT_REMOTE_HOST" "tailscale ip -4" 2>/dev/null | head -1 || echo "")
      if [ -n "$TAILSCALE_IP" ]; then
        break
      fi
    done
    
    success "Instance running"
    if [ -n "${TAILSCALE_IP:-}" ]; then
      echo "  Tailscale IP: $TAILSCALE_IP"
    else
      log_warn "Tailscale not connected yet. Run 'sudo tailscale up' on the remote server."
    fi
    ;;
    
  stop)
    log_info "Stopping instance $SLOT_AWS_INSTANCE_ID..."
    aws ec2 stop-instances \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" \
      --output text > /dev/null
    
    log_info "Waiting for instance to be stopped..."
    aws ec2 wait instance-stopped \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION"
    
    success "Instance stopped"
    ;;
    
  status)
    STATE=$(aws ec2 describe-instances \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" \
      --query 'Reservations[0].Instances[0].State.Name' \
      --output text)
    
    echo "Instance: $SLOT_AWS_INSTANCE_ID"
    echo "State: $STATE"
    
    if [ "$STATE" = "running" ]; then
      PUBLIC_IP=$(aws ec2 describe-instances \
        --instance-ids "$SLOT_AWS_INSTANCE_ID" \
        --region "$SLOT_AWS_REGION" \
        --query 'Reservations[0].Instances[0].PublicIpAddress' \
        --output text)
      
      echo "Public IP: $PUBLIC_IP"
      
      if [ -n "${SLOT_REMOTE_HOST:-}" ]; then
        TAILSCALE_IP=$(ssh "$SLOT_REMOTE_HOST" "tailscale ip -4" 2>/dev/null | head -1 || echo "not connected")
        echo "Tailscale IP: $TAILSCALE_IP"
      fi
    fi
    ;;
    
  info)
    # Parse --detail flag if present
    SHOW_DETAIL=false
    if [ "${2:-}" = "--detail" ] || [ "${2:-}" = "-d" ]; then
      SHOW_DETAIL=true
    fi
    
    echo ""
    
    # Get instance status
    log_info "EC2 Instance"
    INSTANCE_DATA=$(aws ec2 describe-instances \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" \
      --query 'Reservations[0].Instances[0].[State.Name,PublicIpAddress,PrivateIpAddress,InstanceType]' \
      --output text)
    
    STATE=$(echo "$INSTANCE_DATA" | awk '{print $1}')
    PUBLIC_IP=$(echo "$INSTANCE_DATA" | awk '{print $2}')
    PRIVATE_IP=$(echo "$INSTANCE_DATA" | awk '{print $3}')
    INSTANCE_TYPE=$(echo "$INSTANCE_DATA" | awk '{print $4}')
    
    echo "  State:         $STATE"
    echo "  Instance Type: $INSTANCE_TYPE"
    echo "  Public IP:     $PUBLIC_IP"
    echo "  Private IP:    $PRIVATE_IP"
    echo ""
    
    # Check if server is reachable
    if ! ssh -o ConnectTimeout=5 "$SLOT_REMOTE_HOST" "echo ok" &>/dev/null; then
      log_warn "Server not reachable via SSH"
      log_info "Run 'slot server start' to start the server"
      exit 0
    fi
    
    # Batch all remote data collection in single SSH call
    log_info "Collecting resource data..."
    REMOTE_DATA=$(ssh "$SLOT_REMOTE_HOST" bash << REMOTE_SCRIPT
      set -euo pipefail
      
      BASE_DIR="${SLOT_REMOTE_BASE}"
      
      # Get Tailscale IP
      tailscale_ip=\$(tailscale ip -4 2>/dev/null | head -1 || echo "unknown")
      
      # System resources
      cpu_cores=\$(nproc)
      cpu_load=\$(cat /proc/loadavg | awk '{print \$1}')
      
      # Memory in MB
      mem_total=\$(free -m | awk '/^Mem:/ {print \$2}')
      mem_used=\$(free -m | awk '/^Mem:/ {print \$3}')
      mem_free=\$(free -m | awk '/^Mem:/ {print \$7}')  # available column
      
      # Disk
      disk_info=\$(df -BG / | tail -1 | awk '{gsub("G",""); print \$2 "|" \$3 "|" \$4}')
      
      # Get all slots
      slots=\$(ls -1 "\$BASE_DIR" 2>/dev/null | grep -v '^repo.git\$' | grep -v '^\\.env-templates\$' | grep -v '^local-' || true)
      
      # Output system info
      echo "TAILSCALE_IP|\${tailscale_ip}"
      echo "CPU_CORES|\${cpu_cores}"
      echo "CPU_LOAD|\${cpu_load}"
      echo "MEM_TOTAL|\${mem_total}"
      echo "MEM_USED|\${mem_used}"
      echo "MEM_FREE|\${mem_free}"
      echo "DISK_INFO|\${disk_info}"
      
      # Per-slot data
      echo "SLOTS_START"
      for slot in \$slots; do
        if [ -d "\$BASE_DIR/\$slot" ]; then
          # Get containers for this slot's compose project
          project_name="${SLOT_PROJECT_NAME}-\${slot}"
          
          # Count running containers
          running=\$(docker ps --filter "name=\${project_name}" -q 2>/dev/null | wc -l || echo 0)
          total=\$(docker ps -a --filter "name=\${project_name}" -q 2>/dev/null | wc -l || echo 0)
          
          # Get CPU and memory for this slot's containers
          if [ "\$running" -gt 0 ]; then
            # Get stats for all containers in this project
            stats=\$(docker stats --no-stream --format "{{.Name}}|{{.CPUPerc}}|{{.MemUsage}}" 2>/dev/null | grep "^\${project_name}" || true)
            
            # Sum CPU percentages
            slot_cpu=\$(echo "\$stats" | awk -F'|' '{gsub("%","",\$2); sum+=\$2} END {printf "%.1f", sum}')
            [ -z "\$slot_cpu" ] && slot_cpu="0.0"
            
            # Sum memory (extract first number which is usage in MiB/GiB)
            slot_mem=0
            while IFS='|' read -r name cpu mem; do
              # Extract memory value and unit
              mem_val=\$(echo "\$mem" | awk '{print \$1}' | sed 's/[^0-9.]//g')
              mem_unit=\$(echo "\$mem" | awk '{print \$1}' | sed 's/[0-9.]//g')
              if [ "\$mem_unit" = "GiB" ]; then
                mem_val=\$(echo "\$mem_val * 1024" | bc 2>/dev/null || echo 0)
              fi
              slot_mem=\$(echo "\$slot_mem + \$mem_val" | bc 2>/dev/null || echo 0)
            done <<< "\$stats"
            slot_mem=\$(printf "%.0f" "\$slot_mem")
          else
            slot_cpu="0.0"
            slot_mem="0"
          fi
          
          echo "SLOT|\${slot}|\${running}|\${total}|\${slot_cpu}|\${slot_mem}"
        fi
      done
      echo "SLOTS_END"
      
      # Container details (if requested)
      echo "CONTAINERS_START"
      for slot in \$slots; do
        if [ -d "\$BASE_DIR/\$slot" ]; then
          project_name="${SLOT_PROJECT_NAME}-\${slot}"
          running=\$(docker ps --filter "name=\${project_name}" -q 2>/dev/null | wc -l || echo 0)
          
          if [ "\$running" -gt 0 ]; then
            docker stats --no-stream --format "CONTAINER|\${slot}|{{.Name}}|{{.CPUPerc}}|{{.MemUsage}}" 2>/dev/null | grep "|\${project_name}" || true
          fi
        fi
      done
      echo "CONTAINERS_END"
    REMOTE_SCRIPT
    )
    
    # Parse system data
    TAILSCALE_IP=$(echo "$REMOTE_DATA" | grep "^TAILSCALE_IP|" | cut -d'|' -f2)
    CPU_CORES=$(echo "$REMOTE_DATA" | grep "^CPU_CORES|" | cut -d'|' -f2)
    CPU_LOAD=$(echo "$REMOTE_DATA" | grep "^CPU_LOAD|" | cut -d'|' -f2)
    MEM_TOTAL=$(echo "$REMOTE_DATA" | grep "^MEM_TOTAL|" | cut -d'|' -f2)
    MEM_USED=$(echo "$REMOTE_DATA" | grep "^MEM_USED|" | cut -d'|' -f2)
    MEM_FREE=$(echo "$REMOTE_DATA" | grep "^MEM_FREE|" | cut -d'|' -f2)
    DISK_INFO=$(echo "$REMOTE_DATA" | grep "^DISK_INFO|" | cut -d'|' -f2-)
    DISK_TOTAL=$(echo "$DISK_INFO" | cut -d'|' -f1)
    DISK_USED=$(echo "$DISK_INFO" | cut -d'|' -f2)
    DISK_FREE=$(echo "$DISK_INFO" | cut -d'|' -f3)
    
    # Display system resources
    echo ""
    log_info "Server Resources"
    echo "  Tailscale IP:  $TAILSCALE_IP"
    echo ""
    echo "  CPU:   ${CPU_LOAD} load avg (${CPU_CORES} cores)"
    echo "  RAM:   ${MEM_USED} MB / ${MEM_TOTAL} MB used (${MEM_FREE} MB free)"
    echo "  Disk:  ${DISK_USED} GB / ${DISK_TOTAL} GB used (${DISK_FREE} GB free)"
    
    # Parse and display per-slot data
    echo ""
    log_info "Per Slot Resources"
    
    SLOT_LINES=$(echo "$REMOTE_DATA" | sed -n '/^SLOTS_START$/,/^SLOTS_END$/p' | grep "^SLOT|" || true)
    
    if [ -z "$SLOT_LINES" ]; then
      echo "  No slots found"
    else
      # Table header
      printf "  ${CYAN}%-15s %8s %10s %12s${NC}\n" "SLOT" "CPU" "RAM" "CONTAINERS"
      printf "  %-15s %8s %10s %12s\n" "---------------" "--------" "----------" "------------"
      
      TOTAL_CPU=0
      TOTAL_MEM=0
      TOTAL_CONTAINERS=0
      
      while IFS='|' read -r _ slot running total cpu mem; do
        # Format memory
        if [ "$mem" -ge 1024 ]; then
          mem_display=$(echo "scale=1; $mem / 1024" | bc)" GB"
        else
          mem_display="${mem} MB"
        fi
        
        # Status indicator
        if [ "$running" -gt 0 ]; then
          status="${GREEN}${running} running${NC}"
        else
          status="${YELLOW}${total} stopped${NC}"
        fi
        
        printf "  %-15s %7s%% %10s %12b\n" "$slot" "$cpu" "$mem_display" "$status"
        
        # Accumulate totals
        TOTAL_CPU=$(echo "$TOTAL_CPU + $cpu" | bc)
        TOTAL_MEM=$((TOTAL_MEM + mem))
        TOTAL_CONTAINERS=$((TOTAL_CONTAINERS + running))
      done <<< "$SLOT_LINES"
      
      # Totals row
      printf "  %-15s %8s %10s %12s\n" "---------------" "--------" "----------" "------------"
      
      if [ "$TOTAL_MEM" -ge 1024 ]; then
        TOTAL_MEM_DISPLAY=$(echo "scale=1; $TOTAL_MEM / 1024" | bc)" GB"
      else
        TOTAL_MEM_DISPLAY="${TOTAL_MEM} MB"
      fi
      
      printf "  ${BOLD}%-15s %7s%% %10s %12s${NC}\n" "TOTAL" "$TOTAL_CPU" "$TOTAL_MEM_DISPLAY" "$TOTAL_CONTAINERS"
    fi
    
    # Container details if requested
    if [ "$SHOW_DETAIL" = true ]; then
      echo ""
      log_info "Container Details"
      
      CONTAINER_LINES=$(echo "$REMOTE_DATA" | sed -n '/^CONTAINERS_START$/,/^CONTAINERS_END$/p' | grep "^CONTAINER|" || true)
      
      if [ -z "$CONTAINER_LINES" ]; then
        echo "  No running containers"
      else
        CURRENT_SLOT=""
        while IFS='|' read -r _ slot name cpu mem; do
          if [ "$slot" != "$CURRENT_SLOT" ]; then
            echo ""
            echo -e "  ${CYAN}=== Slot: $slot ===${NC}"
            printf "  %-35s %8s %15s\n" "CONTAINER" "CPU" "MEMORY"
            CURRENT_SLOT="$slot"
          fi
          
          # Shorten container name (remove project prefix)
          short_name=$(echo "$name" | sed "s/^${SLOT_PROJECT_NAME}-${slot}-//")
          printf "  %-35s %8s %15s\n" "$short_name" "$cpu" "$mem"
        done <<< "$CONTAINER_LINES"
      fi
    fi
    
    echo ""
    ;;
    
  recreate)
    echo ""
    log_warn "This will TERMINATE the current EC2 instance and create a new one."
    log_warn "All remote data (node_modules, build caches, databases) will be LOST."
    log_warn "Local code is preserved (synced via Mutagen)."
    echo ""
    echo "Current instance: $SLOT_AWS_INSTANCE_ID"
    echo ""
    read -p "Are you sure? (yes/no): " CONFIRM
    
    if [ "$CONFIRM" != "yes" ]; then
      log_info "Cancelled."
      exit 0
    fi
    
    # Clean up local Mutagen syncs
    log_info "Terminating Mutagen syncs..."
    mutagen sync terminate --all 2>/dev/null || true
    
    # Terminate the EC2 instance
    log_info "Terminating EC2 instance $SLOT_AWS_INSTANCE_ID..."
    aws ec2 terminate-instances \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" \
      --output text > /dev/null
    
    log_info "Waiting for instance to terminate..."
    aws ec2 wait instance-terminated \
      --instance-ids "$SLOT_AWS_INSTANCE_ID" \
      --region "$SLOT_AWS_REGION" 2>/dev/null || true
    
    success "Instance terminated."
    echo ""
    
    # Check for Tailscale auth key
    if [ -z "${TAILSCALE_AUTH_KEY:-}" ]; then
      log_warn "TAILSCALE_AUTH_KEY not set."
      echo ""
      echo "Get a reusable auth key from: https://login.tailscale.com/admin/settings/keys"
      echo "Then run:"
      echo "  export TAILSCALE_AUTH_KEY=tskey-auth-xxx"
      echo "  slot server recreate"
      exit 1
    fi
    
    # Create new instance
    log_info "Creating new EC2 instance..."
    FLOWSLOT_DIR="${FLOWSLOT_DIR:-$HOME/.flowslot}"
    CREATE_SCRIPT="$FLOWSLOT_DIR/infra/create-instance.sh"
    
    if [ ! -x "$CREATE_SCRIPT" ]; then
      die "create-instance.sh not found at $CREATE_SCRIPT"
    fi
    
    # Run create-instance and capture output
    CREATE_OUTPUT=$("$CREATE_SCRIPT" 2>&1) || {
      log_error "Failed to create new instance"
      echo "$CREATE_OUTPUT"
      exit 1
    }
    
    echo "$CREATE_OUTPUT"
    
    # Extract new instance ID and Tailscale IP from output
    NEW_INSTANCE_ID=$(echo "$CREATE_OUTPUT" | grep -o 'i-[a-z0-9]\{17\}' | head -1 || echo "")
    NEW_TAILSCALE_IP=$(echo "$CREATE_OUTPUT" | grep -oE '100\.[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
    
    if [ -z "$NEW_INSTANCE_ID" ]; then
      log_warn "Could not extract new instance ID from output."
      log_warn "Update .slotconfig manually with the new SLOT_AWS_INSTANCE_ID and SLOT_REMOTE_HOST."
      exit 0
    fi
    
    # Update .slotconfig
    SLOTCONFIG="$SLOT_SOURCE_DIR/.slotconfig"
    if [ -f "$SLOTCONFIG" ]; then
      log_info "Updating .slotconfig..."
      
      # Update instance ID
      sed -i.bak "s/SLOT_AWS_INSTANCE_ID=.*/SLOT_AWS_INSTANCE_ID=\"$NEW_INSTANCE_ID\"/" "$SLOTCONFIG"
      
      # Update remote host if we got Tailscale IP
      if [ -n "$NEW_TAILSCALE_IP" ]; then
        sed -i.bak "s/SLOT_REMOTE_HOST=.*/SLOT_REMOTE_HOST=\"ubuntu@$NEW_TAILSCALE_IP\"/" "$SLOTCONFIG"
      fi
      
      rm -f "${SLOTCONFIG}.bak"
      success "Updated .slotconfig with new instance details."
    else
      log_warn ".slotconfig not found at $SLOTCONFIG"
      echo "Update manually:"
      echo "  SLOT_AWS_INSTANCE_ID=\"$NEW_INSTANCE_ID\""
      [ -n "$NEW_TAILSCALE_IP" ] && echo "  SLOT_REMOTE_HOST=\"ubuntu@$NEW_TAILSCALE_IP\""
    fi
    
    echo ""
    log_info "Server recreated successfully!"
    echo ""
    echo "Next steps:"
    echo "  1. Configure Tailscale Split DNS (if IP changed)"
    echo "  2. Recreate your slots:"
    
    # List local slot directories
    if [ -d "$SLOT_SLOTS_DIR" ]; then
      for slot_dir in "$SLOT_SLOTS_DIR"/*/; do
        slot_name=$(basename "$slot_dir")
        if [ "$slot_name" != "repo.git" ] && [ "$slot_name" != ".env-templates" ]; then
          echo "     slot destroy $slot_name && slot create $slot_name <branch>"
        fi
      done
    fi
    echo ""
    ;;
    
  *)
    log_error "Unknown command: $COMMAND"
    echo ""
    show_help
    exit 1
    ;;
esac

